This implementation formalizes the following concepts:
%
\begin{itemize}
\item Core categorical concepts
\subitem Categories
\subitem Functors
\subitem Products
\subitem Exponentials
\subitem Cartesian closed categories
\subitem Natural transformations
\subitem Yoneda embedding
\subitem Monads
\subsubitem Monoidal monads
\subsubitem Kleisli monads
\subsubitem Voevodsky's construction
\item Category of \ldots
\subitem Homotopy sets
\subitem Categories -- only data-part
\subitem Relations -- only data-part
\subitem Functors -- only as a precategory
\subitem Free category
\end{itemize}
%
Since it is useful to distinguish between types with more or less (homotopical)
structure I have followed the following design-principle: I have split concepts
up into things that represent ``data'' and ``laws'' about this data. The idea is
that we can provide a proof that the laws are mere propositions. As an example a
category is defined to have two members: `raw` which is a collection of the data
and `isCategory` which asserts some laws about that data.

This allows me to reason about things in a more mathematical way, where one can
reason about two categories by simply focusing on the data. This is acheived by
creating a function embodying the ``equality principle'' for a given type.

\section{Categories}
The data for a category consist of objects, morphisms (or arrows as I will refer
to them henceforth), the identity arrow and composition of arrows.

Another record encapsulates some laws about this data: associativity of
composition, identity law for the identity morphism. These are standard
requirements for being a category as can be found in standard mathematical
expositions on the topic. We, however, impose one further requirement on what it
means to be a category, namely that the type of arrows form a set. We could
relax this requirement, this would give us the notion of higher categorier
(\cite[p. 307]{hott-2013}). For the purpose of this project, however, this
report will restrict itself to 1-categories.

Raw categories satisfying these properties are called a pre-categories.

As a further requirement to be a proper category we require it to be univalent.
This requirement is quite similiar to univalence for types, but we let
isomorphism on objects play the role of equivalence on types. The univalence
criterion is:
%
$$
\isEquiv\ (A \equiv B)\ (A \approxeq B)\ \idToIso
$$
%
Here $\approxeq$ denotes isomorphism on objects (whereas $\cong$ denotes
isomorphism of types).

Note that this is not the same as:
%
$$
(A \equiv B) \simeq (A \approxeq B)
$$
%
The two types are logically equivalent, however. One can construct the latter
from the formerr simply by ``forgetting'' that $\idToIso$ plays the role
of the equivalence. The other direction is more involved.

With all this in place it is now possible to prove that all the laws are indeed
mere propositions. Most of the proofs simply use the fact that the type of
arrows are sets. This is because most of the laws are a collection of equations
between arrows in the category. And since such a proof does not have any content
exactly because the type of arrows form a set, two witnesses must be the same.
All the proofs are really quite mechanical. Lets have a look at one of them: The
identity law states that:
%
$$
\prod_{A\ B \tp \Object} \prod_{f \tp A \to B} \id \comp f \equiv f \x f \comp \id \equiv f
$$
%
There are multiple ways to prove this. Perhaps one of the more intuitive proofs
is by way of the following `combinators':
%
$$
\mathit{propPi} \tp \left(\prod_{a \tp A} \isProp\ (P\ a)\right) \to \isProp\ \left(\prod_{a \tp A} P\ a\right)
$$
%
I.e.; pi-types preserve propositionality when the co-domain is always a
proposition.
%
$$
\mathit{propSig} \tp \isProp\ A \to \left(\prod_{a \tp A} \isProp\ (P\ a)\right) \to \isProp\ \left(\sum_{a \tp A} P\ a\right)
$$
%
I.e.; sigma-types preserve propositionality whenever it's first component is a
proposition, and it's second component is a proposition for all points of in the
left type.

So the proof goes like this: We `eliminate' the 3 function abstractions by
applying $\propPi$ three times. So our proof obligation becomes:
%
$$
\isProp \left( \id \comp f \equiv f \x f \comp \id \equiv f \right)
$$
%
then we eliminate the (non-dependent) sigma-type by applying $\propSig$ giving
us the two obligations: $\isProp\ (\id \comp f \equiv f)$ and $\isProp\ (f \comp
\id \equiv f)$ which follows from the type of arrows being a set.

This example illustrates nicely how we can use these combinators to reason about
`canonical' types like $\sum$ and $\prod$. Similiar combinators can be defined
at the other homotopic levels. These combinators are however not applicable in
situations where we want to reason about other types - e.g. types we've defined
ourselves. For instance, after we've proven that all the projections of
pre-categories are propositions, then we would like to bundle this up to show
that the type of pre-categories is also a proposition. Since pre-categories are
not formulated with a chain of sigma-types we wont have any combinators
available to help us here. In stead we'll have to use the path-type directly.

What we want to prove is:
%
$$
\isProp\ \IsPreCategory
$$
%
Which is judgmentally the same as
%
$$
\prod_{a\ b \tp \IsPreCategory} a \equiv b
$$
%
So let $a\ b \tp \IsPreCategory$ be given. To prove the equality $a \equiv b$ is
to give a continuous path from the index-type into path-space - in this case
$\IsPreCategory$. This path must satisfy being being judgmentally the same as
$a$ at the left endpoint and $b$ at the right endpoint. I.e. a function $I \to
\IsPreCategory$. We know we can form a continuous path between all projections
of $a$ and $b$, this follows from the type of all the projections being mere
propositions. For instance, the path between $\isIdentity_a$ and $\isIdentity_b$
is simply formed by:
%
$$
\propIsIdentity\ \isIdentity_a\ \isIdentity_b \tp \isIdentity_a \equiv \isIdentity_b
$$
%
So to give the continuous function $I \to \IsPreCategory$ that is our goal we
introduce $i \tp I$ and proceed by constructing an element of $\IsPreCategory$
by using that all the projections are propositions to generate paths between all
projections. Once we have such a path e.g. $p : \isIdentity_a \equiv
\isIdentity_b$ we can elimiate it with $i$ and thus obtaining $p\ i \tp
\isIdentity_{p\ i}$ and this element satisfies exactly that it corresponds to
the corresponding projections at either endpoint. Thus the element we construct
at $i$ becomes:
%
\begin{align*}
  & \{\ \mathit{propIsAssociative}\   \mathit{isAssociative}_x\
       \mathit{isAssociative}_y\ i  \\
  & ,\  \mathit{propIsIdentity}\      \mathit{isIdentity}_x\
       \mathit{isIdentity}_y\ i  \\
  & ,\  \mathit{propArrowsAreSets}\ \mathit{arrowsAreSets}_x\
       \mathit{arrowsAreSets}_y\ i  \\
  & \}
\end{align*}
%
I've found that this to be a general pattern when proving things in homotopy
type theory, namely that you have to wrap and unwrap equalities at different
levels. It is worth noting that proving this theorem with the regular inductive
equality type would already not be possible, since we at least need
extensionality (the projections are all $\prod$-types). Assuming we had
functional extensionality available to us as an axiom, we would use functional
extensionality (in reverse?) to retreive the equalities in $a$ and $b$,
pattern-match on them to see that they are both $\mathit{refl}$ and then close
the proof with $\mathit{refl}$. Of course this theorem is not so interesting in
the setting of ITT since we know a priori that equality proofs are unique.

The situation is a bit more complicated when we have a dependent type. For
instance, when we want to show that $\IsCategory$ is a mere proposition.
$\IsCategory$ is a record with two fields, a witness to being a pre-category and
the univalence condition. Recall that the univalence condition is indexed by the
identity-proof. So if we follow the same recipe as above, let $a\ b \tp
\IsCategory$, to show them equal, we now need to give two paths. One homogenous:
%
$$
p_{\isPreCategory} \tp \isPreCategory_a \equiv \isPreCategory_b
$$
%
and one heterogeneous:
%
$$
Path\ (\lambda i \to Univalent_{p\ i})\ \isPreCategory_a\ \isPreCategory_b
$$
%
Which depends on the choice of $p_{\isPreCategory}$. The first of these we can
provide since, as we have shown, $\IsPreCategory$ is a proposition. However,
even though $\Univalent$ is also a proposition, we cannot use this directly to
show the latter. This is becasue $\isProp$ talks about non-dependent paths. To
`promote' this to a dependent path we can use another useful combinator;
$\lemPropF$. Given a type $A \tp \MCU$ and a type family on $A$; $B : A \to
\MCU$. Let $P$ be a proposition indexed by an element of $A$ and say we have a
path between some two elements in $A$; $p : a_0 \equiv a_1$ then we can built a
heterogeneous path between any two $b$'s at the endpoints:
%
$$
Path\ (\lambda i \to B\ (p\ i))\ b0\ b1
$$
%
where $b_0 \tp B a_0$ and $b_1 \tp B\ a_1$. This is quite a mouthful, but the
example at present should serve as an illustration. In this case $A =
\mathit{IsIdentity}\ \mathit{identity}$ and $B = \mathit{Univalent}$ we've shown
that being a category is a proposition, a result that holds for any choice of
identity proof. Finally we must provide a proof that the identity proofs at $a$
and $b$ are indeed the same, this we can extract from $p_{\isPreCategory}$ by
applying using congruence of paths: $\congruence\ \mathit{isIdentity}\
p_{\isPreCategory}$

When we have a proper category we can make precise the notion of ``identifying
isomorphic types'' (TODO cite awodey here). That is, we can construct the
function:
%
$$
\isoToId \tp (A \approxeq B) \to (A \equiv B)
$$
%
One application of this, and a perhaps somewhat surprising result, is that
terminal objects are propositional. Intuitively; they do not have any
interesting structure. The proof of this follows from the usual observation that
any two terminal objects are isomorphic. The proof is omitted here, but the
curious reader can check the implementation for the details. (TODO: The proof is
a bit fun, should I include it?)

\section{Equivalences}
\label{equiv}
The usual notion of a function $f : A \to B$ having an inverses is:
%
$$
\sum_{g : B \to A} f \comp g \equiv \identity_{B} \x g \comp f \equiv \identity_{A}
$$
%
This is defined in \cite[p. 129]{hott-2013} and is referred to as the a
quasi-inverse. At the same place \cite{hott-2013} gives an ``interface'' for
what an equivalence $\isEquiv : (A \to B) \to \MCU$ must supply:
%
\begin{itemize}
\item
  $\qinv\ f \to \isEquiv\ f$
\item
  $\isEquiv\ f \to \qinv\ f$
\item
  $\isEquiv\ f$ is a proposition
\end{itemize}
%
Having such an interface gives us both 1) a way to think rather abstractly about
how to work with equivalences and 2) to use ad-hoc definitions of equivalences.
The specific instantiation of $\isEquiv$ as defined in \cite{cubical} is:
%
$$
isEquiv\ f \defeq \prod_{b : B} \isContr\ (\fiber\ f\ b)
$$
where
$$
\fiber\ f\ b \defeq \sum_{a \tp A} b \equiv f\ a
$$
%
I give it's definition here mainly for completeness, because as I stated we can
move away from this specific instantiation and think about it more abstractly
once we have shown that this definition actually works as an equivalence.

The first function from the list of requirements we will call
$\mathit{fromIsomorphism}$, this is known as $\mathit{gradLemma}$ in
\cite{cubical} the second one we will refer to as $\mathit{toIsmorphism}$. It's
implementation can be found in the sources. Likewise the proof that this
equivalence is propositional can be found in my implementation.

We say that two types $A\;B \tp \Type$ are equivalent exactly if there exists an
equivalence between them:
%
$$
A \simeq B \defeq \sum_{f \tp A \to B} \isEquiv\ f
$$
%
Note that the term equivalence here is overloaded referring both to the map $f
\tp A \to B$ and the type $A \simeq B$. I will use these conflated terms when it
it is clear from the context what is being referred to.

Just like we could promote a quasi-inverse to an equivalence we can promote an
isomorphism to an equivalence:
%
$$
\mathit{fromIsomorphism} \tp A \cong B \to A \simeq B
$$
%
and vice-versa:
%
$$
\mathit{toIsomorphism} \tp A \simeq B \to A \cong B
$$
%
The notion of an isomorphism is similarly conflated as isomorphism can refer to
the type $A \cong B$ as well as the the map $A \to B$ that witness this.

Both $\cong$ and $\simeq$ form equivalence relations.

\section{Univalence}
\label{univalence}
As noted in the introduction the univalence for types $A\; B \tp \Type$ states
that:
%
$$
\mathit{Univalence} \defeq (A \equiv B) \simeq (A \simeq B)
$$
%
As mentioned the univalence criterion for some category $\bC$ says that for all
\emph{objects} $A\;B$ we must have:
$$
\isEquiv\ (A \equiv B)\ (A \approxeq B)\ \idToIso
$$
And I mentioned that this was logically equivalent to
%
$$
(A \equiv B) \simeq (A \approxeq B)
$$
%
Given that we saw in the previous section that we can construct an equivalence
from an isomorphism it suffices to demonstrate:
%
$$
(A \equiv B) \cong (A \approxeq B)
$$
%
That is, we must demonstrate that there is an isomorphism (on types) between
equalities and isomorphisms (on arrows). It's worthwhile to dwell on this for a
few seconds. This type looks very similar to univalence for types and is
therefore perhaps a bit more intuitive to grasp the implications of. Of course
univalence for types (which is a proposition -- i.e. provable) does not imply
univalence in any category since morphisms in a category are not regular maps --
in stead they can be thought of as a generalization hereof; i.e. arrows. The
univalence criterion therefore is simply a way of restricting arrows to behave
similarly to maps.

I will now mention a few helpful thoerems that follow from univalence that will
become useful later.

Obviously univalence gives us an isomorphism $A \equiv B \to A \approxeq B$. I
will name these for convenience:
%
$$
\idToIso \tp A \equiv B \to A \approxeq B
$$
%
$$
\isoToId \tp A \approxeq B \to A \equiv B
$$
%
The next few theorems are variations on theorem 9.1.9 from \cite{HoTT-book}. Let
an isomorphism $A \approxeq B$ in some category $\bC$ be given. Name the
isomorphism $\iota \tp A \to B$ and its inverse $\widetilde{\iota} \tp B \to A$.
Since $\bC$ is a category (and therefore univalent) the isomorphism induces a
path $p \tp A \equiv B$. From this equality we can get two further paths:
$p_{\mathit{dom}} \tp \mathit{Arrow}\ A\ X \equiv \mathit{Arrow}\ A'\ X$ and
$p_{\mathit{cod}} \tp \mathit{Arrow}\ X\ A \equiv \mathit{Arrow}\ X\ A'$. We
then have the following two theorems:
%
$$
\mathit{coeDom} \tp \prod_{f \tp A \to X} \mathit{coe}\ p_{\mathit{dom}}\ f \equiv f \lll \widetilde{\iota}
$$
%
%
$$
\mathit{coeCod} \tp \prod_{f \tp A \to X} \mathit{coe}\ p_{\mathit{cod}}\ f \equiv \iota \lll f
$$
%
I will give the proof of the first theorem here, the second one is analagous.
\begin{align*}
\mathit{coe}\ p_{\mathit{dom}}\ f
  & \equiv f \lll \mathit{obverse}_{\mathit{idToIso}\ p} && \text{lemma} \\
  & \equiv f \lll \widetilde{\iota}
    && \text{$\mathit{idToIso}$ and $\mathit{isoToId}$ are inverses}\\
\end{align*}
%
In the second step we use the fact that $p$ is constructed from the isomorphism
$\iota$ -- $\mathit{obverse}$ denotes the map $B \to A$ induced by the
isomorphism $\mathit{idToIso}\ p \tp A \cong B$. The helper-lemma is similar to
what we're trying to prove but talks about paths rather than isomorphisms:
%
$$
\prod_{f \tp \mathit{Arrow}\ A\ B} \prod_{p \tp A \equiv A'} \mathit{coe}\ p^*\ f \equiv f \lll \mathit{obverse}_{\mathit{idToIso}\ p}
$$
%
Note that the asterisk in $p^*$ denotes the path $\mathit{Arrow}\ A\ B \equiv
\mathit{Arrow}\ A'\ B$ induced by $p$. To prove this statement I let $f$ and $p$
be given and then invoke based-path-induction. The induction will be based at $A
\tp \mathit{Object}$, so let $\widetilde{A} \tp \Object$ and $\widetilde{p} \tp
A \equiv \widetilde{A}$ be given. The family that we perform induction over will
be:
%
$$
\mathit{coe}\ {\widetilde{p}}^*\ f \equiv f \lll \mathit{obverse}_{\mathit{idToIso}\ \widetilde{p}}
$$
The base-case therefore becomes:
\begin{align*}
\mathit{coe}\ {\widetilde{\refl}}^*\ f
& \equiv f \\
& \equiv f \lll \mathit{identity} \\
& \equiv f \lll \mathit{obverse}_{\mathit{idToIso}\ \widetilde{\refl}}
\end{align*}
%
The first step follows because reflixivity is a neutral element for coercions.
The second step is the identity law in the category. The last step has to do
with the fact that $\mathit{idToIso}$ is constructed by substituting according
to the supplied path and since reflexivity is also the neutral element for
substuitutions we arrive at the desired expression. To close the
based-path-induction we must supply the value at the other end and the
connecting path, but in this case this is simply $A' \tp \Object$ and $p \tp A
\equiv A'$ which we have.
%
\section{Categories}
\subsection{Opposite category}
\label{op-cat}
The first category I'll present is a pure construction on categories. Given some
category we can construct it's dual, called the opposite category. Starting with
a simple example allows us to focus on how we work with equivalences and
univalence in a very simple category where the structure of the category is
rather simple.

Let $\bC$ be some category, we then define the opposite category
$\bC^{\matit{Op}}$. It has the same objects, but the type of arrows are flipped,
that is to say an arrow from $A$ to $B$ in the opposite category corresponds to
an arrow from $B$ to $A$ in the underlying category. The identity arrow is the
same as the one in the underlying category (they have the same type). Function
composition will be reverse function composition from the underlying category.

Showing that this forms a pre-category is rather straightforward. I'll state the
laws in terms of the underlying category $\bC$:
%
$$
h \rrr (g \rrr f) \equiv h \rrr g \rrr f
$$
%
Since $\rrr$ is reverse function composition this is just the symmetric version
of associativity.
%
$$
\matit{identity} \rrr f \equiv f \x f \rrr identity \equiv f
$$
%
This is just the swapped version of identity.

Finally, that the arrows form sets just follows by flipping the order of the
arguments. Or in other words since $\Hom_{A\ B}$ is a set for all $A\ B \tp
\Object$ then so is $\Hom_{B\ A}$.

Now, to show that this category is univalent is not as straight-forward. Lucliy
section \ref{equiv} gave us some tools to work with equivalences. We saw that we
can prove this category univalent by giving an inverse to
$\idToIso_{\mathit{Op}} \tp (A \equiv B) \to (A \approxeq_{\mathit{Op}} B)$.
From the original category we have that $\idToIso \tp (A \equiv B) \to (A \cong
B)$ is an isomorphism. Let us denote it's inverse with $\eta \tp (A \approxeq B)
\to (A \equiv B)$. If we squint we can see what we need is a way to go between
$\approxeq_{\mathit{Op}}$ and $\approxeq$, well, an inhabitant of $A \approxeq
B$ is simply an arrow $f \tp \mathit{Arrow}\ A\ B$ and it's inverse $g \tp
\mathit{Arrow}\ B\ A$. In the opposite category $g$ will play the role of the
isomorphism and $f$ will be the inverse. Similarly we can go in the opposite
direction. I name these maps $\mathit{shuffle} \tp (A \approxeq B) \to (A
\approxeq_{\bC} B)$ and $\mathit{shuffle}^{-1} : (A \approxeq_{\bC} B) \to (A
\approxeq B)$ respectively.

As the inverse of $\idToIso_{\mathit{Op}}$ I will pick $\zeta \defeq \eta \comp
\mathit{shuffle}$. The proof that they are inverses go as follows:
%
\begin{align*}
\zeta \comp \idToIso & \equiv
\eta \comp \shuffle \comp \idToIso
&& \text{by definition} \\
%% ≡⟨ cong (λ φ → φ x) (cong (λ φ → η ⊙ shuffle ⊙ φ) (funExt lem)) ⟩ \\
%
& \equiv
\eta \comp \shuffle \comp \inv{\shuffle} \comp \idToIso
&& \text{lemma} \\
%%   ≡⟨⟩ \\
& \equiv
\eta \comp \idToIso_{\bC}
&& \text{$\shuffle$ is an isomorphism} \\
%%   ≡⟨ (λ i → verso-recto i x) ⟩ \\
& \equiv
\identity
&& \text{$\eta$ is an ismorphism}
\end{align*}
%
The other direction is analogous.

The lemma used in this proof states that $\idToIso \equiv \inv{\shuffle} \comp
\idToIso_{\bC}$ it's a rather straight-forward proof since being-an-inverse-of
is a proposition.

So, in conclusion, we've shown that the opposite category is indeed a category.

This finished the proof that the opposite category is in fact a category. Now,
to prove that that opposite-of is an involution we must show:
%
$$
\prod_{\bC \tp \mathit{Category}} \left(\bC^{\matit{Op}}\right)^{\matit{Op}} \equiv \bC
$$
%
As we've seen the laws in $\left(\bC^{\mathit{Op}}\right)^{\mathit{Op}}$ get
quite involved.\footnote{We haven't even seen the full story because we've used
  this `interface' for equivalences.} Luckily since being-a-category is a mere
proposition, we need not concern ourselves with this bit when proving the above.
We can use the equality principle for categories that lets us prove an equality
just by giving an equality on the data-part. So, given a category $\bC$ all we
must provide is the following proof:
%
$$
\mathit{raw}\ \left(\bC^{\mathit{Op}}\right)^{\mathit{Op}} \equiv \mathit{raw}\ \bC
$$
%
And these are judgmentally the same. I remind the reader that the left-hand side
is constructed by flipping the arrows, which judgmentally is an involution.

\subsection{Category of sets}
The category of sets has as objects, not types, but only those types that are
homotopic sets. This is encapsulated in Agda with the following type:
%
$$\Set_\ell \defeq \sum_{A \tp \MCU_\ell} \isSet\ A$$
%
The more straight-forward notion of a category where the objects are types is
not a valid (1-)category. Since in cubical Agda types can have higher homotopic
structure.

Univalence does not follow immediately from univalence for types:
%
$$(A \equiv B) \simeq (A \simeq B)$$
%
Because here $A\ B \tp \Type$ whereas the objects in this category have the type
$\Set$ so we cannot form the type $\mathit{hA} \simeq \mathit{hB}$ for objects
$\mathit{hA}\;\mathit{hB} \tp \Set$. In stead I show that this category
satisfies:
%
$$
(\mathit{hA} \equiv \mathit{hB}) \simeq (\mathit{hA} \approxeq \mathit{hB})
$$
%
Which, as we saw in section \ref{univalence}, is sufficient to show that the
category is univalent. The way that I have shown this is with a three-step
process. For objects $(A, s_A)\; (B, s_B) \tp \Set$ I show that.
%
\begin{align*}
 ((A, s_A) \equiv (B, s_B)) & \simeq (A \equiv B) \\
 (A \equiv B) & \simeq (\fst A \simeq \fst B) \\
 (A \simeq B) & \simeq ((A, s_A) \approxeq (B, s_B))
\end{align*}

And since $\simeq$ is an equivalence relation we can chain these equivalences
together. Step one will be proven with the following lemma:
%
$$
\left(\prod_{a \tp A} \isProp (P\ a)\right) \to \prod_{x\;y \tp \sum_{a \tp A} P\ a} (x \equiv y) \simeq (\fst\ x \equiv \fst\ y)
$$
%
The lemma states that for pairs whose second component are mere propositions
equiality is equivalent to equality of the first components. In this case the
type-family $P$ is $\isSet$ which itself is a proposition for any type $A \tp
\Type$. Step two is univalence. Step three will be proven with the following
lemma:
%
$$
\prod_{a \tp A} \left( P\ a \simeq Q\ a \right) \to \sum_{a \tp A} P\ a \simeq \sum_{a \tp A} Q\ a
$$
%
Which says that if two type-families are equivalent at all points, then pairs
with identitical first components and these families as second components will
also be equivalent. For our purposes $P \defeq \isEquiv\ A\ B$ and $Q \defeq
\mathit{Isomorphism}$. So we must finally prove:
%
$$
\prod_{f \tp A \to B} \left( \isEquiv\ A\ B\ f \simeq \mathit{Isomorphism}\ f \right)
$$


\subsection{Categories}
Note that this category does in fact not exist. In stead I provide the
definition of the ``raw'' category as well as some of the laws.

Furthermore I provide some helpful lemmas about this raw category. For instance
I have shown what would be the exponential object in such a category.

These lemmas can be used to provide the actual exponential object in a context
where we have a witness to this being a category. This is useful if this library
is later extended to talk about higher categories.


\section{Product}
\section{Monads}

%% \subsubsection{Functors}
%% Defines the notion of a functor - also split up into data and laws.

%% Propositionality for being a functor.

%% Composition of functors and the identity functor.

%% \subsubsection{Products}
%% Definition of what it means for an object to be a product in a given category.

%% Definition of what it means for a category to have all products.

%% \WIP{} Prove propositionality for being a product and having products.

%% \subsubsection{Exponentials}
%% Definition of what it means to be an exponential object.

%% Definition of what it means for a category to have all exponential objects.

%% \subsubsection{Cartesian closed categories}
%% Definition of what it means for a category to be cartesian closed; namely that
%% it has all products and all exponentials.

%% \subsubsection{Natural transformations}
%% Definition of transformations\footnote{Maybe this is a name I made up for a
%%   family of morphisms} and the naturality condition for these.

%% Proof that naturality is a mere proposition and the accompanying equality
%% principle. Proof that natural transformations are homotopic sets.

%% The identity natural transformation.

%% \subsubsection{Yoneda embedding}

%% The yoneda embedding is typically presented in terms of the category of
%% categories (cf. Awodey) \emph however this is not stricly needed - all we need
%% is what would be the exponential object in that category - this happens to be
%% functors and so this is how we define the yoneda embedding.

%% \subsubsection{Monads}

%% Defines an equivalence between these two formulations of a monad:

%% \subsubsubsection{Monoidal monads}

%% Defines the standard monoidal representation of a monad:

%% An endofunctor with two natural transformations (called ``pure'' and ``join'')
%% and some laws about these natural transformations.

%% Propositionality proofs and equality principle is provided.

%% \subsubsubsection{Kleisli monads}

%% A presentation of monads perhaps more familiar to a functional programer:

%% A map on objects and two maps on morphisms (called ``pure'' and ``bind'') and
%% some laws about these maps.

%% Propositionality proofs and equality principle is provided.

%% \subsubsubsection{Voevodsky's construction}

%% Provides construction 2.3 as presented in an unpublished paper by Vladimir
%% Voevodsky. This construction is similiar to the equivalence provided for the two
%% preceding formulations
%% \footnote{ TODO: I would like to include in the thesis some motivation for why
%%   this construction is particularly interesting.}

%% \subsubsection{Functors}
%% The category of functors and natural transformations. An immediate corrolary is
%% the set of presheaf categories.

%% \WIP{} I have not shown that the category of functors is univalent.

%% \subsubsection{Relations}
%% The category of relations. \WIP{} I have not shown that this category is
%% univalent. Not sure I intend to do so either.

%% \subsubsection{Free category}
%% The free category of a category. \WIP{} I have not shown that this category is
%% univalent.

%% \subsection{Current Challenges}
%% Besides the items marked \WIP{} above I still feel a bit unsure about what to
%% include in my report. Most of my work so far has been specifically about
%% developing this library. Some ideas:
%% %
%% \begin{itemize}
%% \item
%%   Modularity properties
%% \item
%%   Compare with setoid-approach to solve similiar problems.
%% \item
%%   How to structure an implementation to best deal with types that have no
%%   structure (propositions) and those that do (sets and everything above)
%% \end{itemize}
%% %
%% \subsection{Ideas for future developments}
%% \subsubsection{Higher categories}
%% I only have a notion of (1-)categories. Perhaps it would be nice to also
%% formalize higher categories.

%% \subsubsection{Hierarchy of concepts related to monads}
%% In Haskell the type-class Monad sits in a hierarchy atop the notion of a functor
%% and applicative functors. There's probably a similiar notion in the
%% category-theoretic approach to developing this.

%% As I have already defined monads from these two perspectives, it would be
%% interesting to take this idea even further and actually show how monads are
%% related to applicative functors and functors. I'm not entirely sure how this
%% would look in Agda though.

%% \subsubsection{Use formulation on the standard library}
%% I also thought it would be interesting to use this library to show certain
%% properties about functors, applicative functors and monads used in the Agda
%% Standard library. So I went ahead and tried to show that agda's standard
%% library's notion of a functor (along with suitable laws) is equivalent to my
%% formulation (in the category of homotopic sets). I ran into two problems here,
%% however; the first one is that the standard library's notion of a functor is
%% indexed by the object map:
%% %
%% $$
%% \Functor \tp (\Type \to \Type) \to \Type
%% $$
%% %
%% Where $\Functor\ F$ has the member:
%% %
%% $$
%% \fmap \tp (A \to B) \to F A \to F B
%% $$
%% %
%% Whereas the object map in my definition is existentially quantified:
%% %
%% $$
%% \Functor \tp \Type
%% $$
%% %
%% And $\Functor$ has these members:
%% \begin{align*}
%% F     & \tp \Type \to \Type \\
%% \fmap & \tp (A \to B) \to F A \to F B\}
%% \end{align*}
%% %
