-- | The category of homotopy sets
{-# OPTIONS --allow-unsolved-metas --cubical --caching #-}
module Cat.Categories.Sets where

open import Cat.Prelude hiding (_‚âÉ_)
import Data.Product

open import Function using (_‚àò_ ; _‚àò‚Ä≤_)

open import Cubical.Univalence using (univalence ; con ; _‚âÉ_ ; idtoeqv ; ua)

open import Cat.Category
open import Cat.Category.Functor
open import Cat.Category.Product
open import Cat.Wishlist
open import Cat.Equivalence as Eqv using (AreInverses ; module Equiv‚âÉ ; module NoEta)

open NoEta

module Equivalence = Equivalence‚Ä≤

_‚äô_ : {‚Ñìa ‚Ñìb ‚Ñìc : Level} {A : Set ‚Ñìa} {B : Set ‚Ñìb} {C : Set ‚Ñìc} ‚Üí (A ‚âÉ B) ‚Üí (B ‚âÉ C) ‚Üí A ‚âÉ C
eqA ‚äô eqB = Equivalence.compose eqA eqB

sym‚âÉ : ‚àÄ {‚Ñìa ‚Ñìb} {A : Set ‚Ñìa} {B : Set ‚Ñìb} ‚Üí A ‚âÉ B ‚Üí B ‚âÉ A
sym‚âÉ = Equivalence.symmetry

infixl 10 _‚äô_

module _ {‚Ñì : Level} {A : Set ‚Ñì} {a : A} where
  id-coe : coe refl a ‚â° a
  id-coe = begin
    coe refl a                 ‚â°‚ü®‚ü©
    pathJ (Œª y x ‚Üí A) _ A refl ‚â°‚ü® pathJprop {x = a} (Œª y x ‚Üí A) _ ‚ü©
    _ ‚â°‚ü® pathJprop {x = a} (Œª y x ‚Üí A) _ ‚ü©
    a ‚àé

module _ {‚Ñì : Level} {A B : Set ‚Ñì} {a : A} where
  inv-coe : (p : A ‚â° B) ‚Üí coe (sym p) (coe p a) ‚â° a
  inv-coe p =
    let
      D : (y : Set ‚Ñì) ‚Üí _ ‚â° y ‚Üí Set _
      D _ q = coe (sym q) (coe q a) ‚â° a
      d : D A refl
      d = begin
        coe (sym refl) (coe refl a) ‚â°‚ü®‚ü©
        coe refl (coe refl a)       ‚â°‚ü® id-coe ‚ü©
        coe refl a                  ‚â°‚ü® id-coe ‚ü©
        a ‚àé
    in pathJ D d B p
  inv-coe' : (p : B ‚â° A) ‚Üí coe p (coe (sym p) a) ‚â° a
  inv-coe' p =
    let
      D : (y : Set ‚Ñì) ‚Üí _ ‚â° y ‚Üí Set _
      D _ q = coe (sym q) (coe q a) ‚â° a
      k : coe p (coe (sym p) a) ‚â° a
      k = pathJ D (trans id-coe id-coe) B (sym p)
    in k

module _ (‚Ñì : Level) where
  private
    SetsRaw : RawCategory (lsuc ‚Ñì) ‚Ñì
    RawCategory.Object SetsRaw = hSet ‚Ñì
    RawCategory.Arrow  SetsRaw (T , _) (U , _) = T ‚Üí U
    RawCategory.ùüô      SetsRaw = Function.id
    RawCategory._‚àò_    SetsRaw = Function._‚àò‚Ä≤_

    open RawCategory SetsRaw hiding (_‚àò_)

    isIdentity : IsIdentity Function.id
    proj‚ÇÅ isIdentity = funExt Œª _ ‚Üí refl
    proj‚ÇÇ isIdentity = funExt Œª _ ‚Üí refl

    open Univalence (Œª {A} {B} {f} ‚Üí isIdentity {A} {B} {f})

    arrowsAreSets : ArrowsAreSets
    arrowsAreSets {B = (_ , s)} = setPi Œª _ ‚Üí s

    isIso = Eqv.Isomorphism
    module _ {hA hB : hSet ‚Ñì} where
      open Œ£ hA renaming (proj‚ÇÅ to A ; proj‚ÇÇ to sA)
      open Œ£ hB renaming (proj‚ÇÅ to B ; proj‚ÇÇ to sB)
      lem1 : (f : A ‚Üí B) ‚Üí isSet A ‚Üí isSet B ‚Üí isProp (isIso f)
      lem1 f sA sB = res
        where
        module _ (x y : isIso f) where
          module x = Œ£ x renaming (proj‚ÇÅ to inverse ; proj‚ÇÇ to areInverses)
          module y = Œ£ y renaming (proj‚ÇÅ to inverse ; proj‚ÇÇ to areInverses)
          module xA = AreInverses x.areInverses
          module yA = AreInverses y.areInverses
          -- I had a lot of difficulty using the corresponding proof where
          -- AreInverses is defined. This is sadly a bit anti-modular. The
          -- reason for my troubles is probably related to the type of objects
          -- being hSet's rather than sets.
          p : ‚àÄ {f} g ‚Üí isProp (AreInverses {A = A} {B} f g)
          p {f} g xx yy i = record
            { verso-recto = ve-re
            ; recto-verso = re-ve
            }
            where
            module xxA = AreInverses xx
            module yyA = AreInverses yy
            ve-re : g ‚àò f ‚â° Function.id
            ve-re = arrowsAreSets {A = hA} {B = hA} _ _ xxA.verso-recto yyA.verso-recto i
            re-ve : f ‚àò g ‚â° Function.id
            re-ve = arrowsAreSets {A = hB} {B = hB} _ _ xxA.recto-verso yyA.recto-verso i
          1eq : x.inverse ‚â° y.inverse
          1eq = begin
            x.inverse                   ‚â°‚ü®‚ü©
            x.inverse ‚àò Function.id     ‚â°‚ü® cong (Œª œÜ ‚Üí x.inverse ‚àò œÜ) (sym yA.recto-verso) ‚ü©
            x.inverse ‚àò (f ‚àò y.inverse) ‚â°‚ü®‚ü©
            (x.inverse ‚àò f) ‚àò y.inverse ‚â°‚ü® cong (Œª œÜ ‚Üí œÜ ‚àò y.inverse) xA.verso-recto ‚ü©
            Function.id ‚àò y.inverse     ‚â°‚ü®‚ü©
            y.inverse                   ‚àé
          2eq : (Œª i ‚Üí AreInverses f (1eq i)) [ x.areInverses ‚â° y.areInverses ]
          2eq = lemPropF p 1eq
          res : x ‚â° y
          res i = 1eq i , 2eq i
    module _ {‚Ñìa ‚Ñìb : Level} {A : Set ‚Ñìa} {P : A ‚Üí Set ‚Ñìb} where
      lem2 : ((x : A) ‚Üí isProp (P x)) ‚Üí (p q : Œ£ A P)
        ‚Üí (p ‚â° q) ‚âÉ (proj‚ÇÅ p ‚â° proj‚ÇÅ q)
      lem2 pA p q = fromIsomorphism iso
        where
        f : ‚àÄ {p q} ‚Üí p ‚â° q ‚Üí proj‚ÇÅ p ‚â° proj‚ÇÅ q
        f e i = proj‚ÇÅ (e i)
        g : ‚àÄ {p q} ‚Üí proj‚ÇÅ p ‚â° proj‚ÇÅ q ‚Üí p ‚â° q
        g {p} {q} = lemSig pA p q
        ve-re : (e : p ‚â° q) ‚Üí (g ‚àò f) e ‚â° e
        ve-re = pathJ (\ q (e : p ‚â° q) ‚Üí (g ‚àò f) e ‚â° e)
                  (\ i j ‚Üí p .proj‚ÇÅ , propSet (pA (p .proj‚ÇÅ)) (p .proj‚ÇÇ) (p .proj‚ÇÇ) (Œª i ‚Üí (g {p} {p} ‚àò f) (Œª i‚ÇÅ ‚Üí p) i .proj‚ÇÇ) (Œª i ‚Üí p .proj‚ÇÇ) i j ) q
        re-ve : (e : proj‚ÇÅ p ‚â° proj‚ÇÅ q) ‚Üí (f {p} {q} ‚àò g {p} {q}) e ‚â° e
        re-ve e = refl
        inv : AreInverses (f {p} {q}) (g {p} {q})
        inv = record
          { verso-recto = funExt ve-re
          ; recto-verso = funExt re-ve
          }
        iso : (p ‚â° q) Eqv.‚âÖ (proj‚ÇÅ p ‚â° proj‚ÇÅ q)
        iso = f , g , inv

      lem3 : {Q : A ‚Üí Set ‚Ñìb}
        ‚Üí ((a : A) ‚Üí P a ‚âÉ Q a) ‚Üí Œ£ A P ‚âÉ Œ£ A Q
      lem3 {Q} eA = res
        where
        P‚ÜíQ : ‚àÄ {a} ‚Üí P a ‚â° Q a
        P‚ÜíQ = ua (eA _)
        Q‚ÜíP : ‚àÄ {a} ‚Üí Q a ‚â° P a
        Q‚ÜíP = sym P‚ÜíQ
        f : Œ£ A P ‚Üí Œ£ A Q
        f (a , pA) = a , _‚âÉ_.eqv (eA a) pA
        g : Œ£ A Q ‚Üí Œ£ A P
        g (a , qA) = a , g' qA
          where
          k : Eqv.Isomorphism _
          k = Equiv‚âÉ.toIso _ _ (_‚âÉ_.isEqv (eA a))
          open Œ£ k renaming (proj‚ÇÅ to g')
        ve-re : (x : Œ£ A P) ‚Üí (g ‚àò f) x ‚â° x
        ve-re x i = proj‚ÇÅ x , eq i
          where
          eq : proj‚ÇÇ ((g ‚àò f) x) ‚â° proj‚ÇÇ x
          eq = begin
            proj‚ÇÇ ((g ‚àò f) x) ‚â°‚ü®‚ü©
            proj‚ÇÇ (g (f (a , pA))) ‚â°‚ü®‚ü©
            g' (_‚âÉ_.eqv (eA a) pA) ‚â°‚ü® lem ‚ü©
            pA ‚àé
            where
            open Œ£ x renaming (proj‚ÇÅ to a ; proj‚ÇÇ to pA)
            k : Eqv.Isomorphism _
            k = Equiv‚âÉ.toIso _ _ (_‚âÉ_.isEqv (eA a))
            open Œ£ k renaming (proj‚ÇÅ to g' ; proj‚ÇÇ to inv)
            module A = AreInverses inv
            -- anti-funExt
            lem : (g' ‚àò (_‚âÉ_.eqv (eA a))) pA ‚â° pA
            lem i = A.verso-recto i pA
        re-ve : (x : Œ£ A Q) ‚Üí (f ‚àò g) x ‚â° x
        re-ve x i = proj‚ÇÅ x , eq i
          where
          open Œ£ x renaming (proj‚ÇÅ to a ; proj‚ÇÇ to qA)
          eq = begin
            proj‚ÇÇ ((f ‚àò g) x)                 ‚â°‚ü®‚ü©
            _‚âÉ_.eqv (eA a) (g' qA)            ‚â°‚ü® (Œª i ‚Üí A.recto-verso i qA) ‚ü©
            qA                                ‚àé
            where
            k : Eqv.Isomorphism _
            k = Equiv‚âÉ.toIso _ _ (_‚âÉ_.isEqv (eA a))
            open Œ£ k renaming (proj‚ÇÅ to g' ; proj‚ÇÇ to inv)
            module A = AreInverses inv
        inv : AreInverses f g
        inv = record
          { verso-recto = funExt ve-re
          ; recto-verso = funExt re-ve
          }
        iso : Œ£ A P Eqv.‚âÖ Œ£ A Q
        iso = f , g , inv
        res : Œ£ A P ‚âÉ Œ£ A Q
        res = fromIsomorphism iso

    module _ {‚Ñìa ‚Ñìb : Level} {A : Set ‚Ñìa} {B : Set ‚Ñìb} where
      lem4 : isSet A ‚Üí isSet B ‚Üí (f : A ‚Üí B)
        ‚Üí isEquiv A B f ‚âÉ isIso f
      lem4 sA sB f =
        let
          obv : isEquiv A B f ‚Üí isIso f
          obv = Equiv‚âÉ.toIso A B
          inv : isIso f ‚Üí isEquiv A B f
          inv = Equiv‚âÉ.fromIso A B
          re-ve : (x : isEquiv A B f) ‚Üí (inv ‚àò obv) x ‚â° x
          re-ve = Equiv‚âÉ.inverse-from-to-iso A B
          ve-re : (x : isIso f)       ‚Üí (obv ‚àò inv) x ‚â° x
          ve-re = Equiv‚âÉ.inverse-to-from-iso A B
          iso : isEquiv A B f Eqv.‚âÖ isIso f
          iso = obv , inv ,
            record
              { verso-recto = funExt re-ve
              ; recto-verso = funExt ve-re
              }
        in fromIsomorphism iso

    module _ {hA hB : Object} where
      private
        A = proj‚ÇÅ hA
        sA = proj‚ÇÇ hA
        B = proj‚ÇÅ hB
        sB = proj‚ÇÇ hB


      -- lem3 and the equivalence from lem4
      step0 : Œ£ (A ‚Üí B) isIso ‚âÉ Œ£ (A ‚Üí B) (isEquiv A B)
      step0 = lem3 (Œª f ‚Üí sym‚âÉ (lem4 sA sB f))
      -- univalence
      step1 : Œ£ (A ‚Üí B) (isEquiv A B) ‚âÉ (A ‚â° B)
      step1 = hh ‚äô h
        where
          h : (A ‚âÉ B) ‚âÉ (A ‚â° B)
          h = sym‚âÉ (univalence {A = A} {B})
          obv : Œ£ (A ‚Üí B) (isEquiv A B) ‚Üí A ‚âÉ B
          obv = Eqv.deEta
          inv : A ‚âÉ B ‚Üí Œ£ (A ‚Üí B) (isEquiv A B)
          inv = Eqv.doEta
          re-ve : (x : _) ‚Üí (inv ‚àò obv) x ‚â° x
          re-ve x = refl
          -- Because _‚âÉ_ does not have eta equality!
          ve-re : (x : _) ‚Üí (obv ‚àò inv) x ‚â° x
          ve-re (con eqv isEqv) i = con eqv isEqv
          areInv : AreInverses obv inv
          areInv = record { verso-recto = funExt re-ve ; recto-verso = funExt ve-re }
          eqv : Œ£ (A ‚Üí B) (isEquiv A B) Eqv.‚âÖ (A ‚âÉ B)
          eqv = obv , inv , areInv
          hh : Œ£ (A ‚Üí B) (isEquiv A B) ‚âÉ (A ‚âÉ B)
          hh = fromIsomorphism eqv

      -- lem2 with propIsSet
      step2 : (A ‚â° B) ‚âÉ (hA ‚â° hB)
      step2 = sym‚âÉ (lem2 (Œª A ‚Üí isSetIsProp) hA hB)

      -- Go from an isomorphism on sets to an isomorphism on homotopic sets
      trivial? : (hA ‚âÖ hB) ‚âÉ Œ£ (A ‚Üí B) isIso
      trivial? = sym‚âÉ (fromIsomorphism res)
        where
        fwd : Œ£ (A ‚Üí B) isIso ‚Üí hA ‚âÖ hB
        fwd (f , g , inv) = f , g , inv.toPair
          where
          module inv = AreInverses inv
        bwd : hA ‚âÖ hB ‚Üí Œ£ (A ‚Üí B) isIso
        bwd (f , g , x , y) = f , g , record { verso-recto = x ; recto-verso = y }
        res : Œ£ (A ‚Üí B) isIso Eqv.‚âÖ (hA ‚âÖ hB)
        res = fwd , bwd , record { verso-recto = refl ; recto-verso = refl }
      conclusion : (hA ‚âÖ hB) ‚âÉ (hA ‚â° hB)
      conclusion = trivial? ‚äô step0 ‚äô step1 ‚äô step2
      thierry : (hA ‚â° hB) ‚âÉ (hA ‚âÖ hB)
      thierry = sym‚âÉ conclusion
      -- TODO Is the morphism `(_‚âÉ_.eqv conclusion)` the same as
      -- `(id-to-iso (Œª {A} {B} ‚Üí isIdentity {A} {B}) hA hB)` ?
      res : isEquiv (hA ‚â° hB) (hA ‚âÖ hB) _
      res = _‚âÉ_.isEqv thierry
      thr : (hA ‚â° hB) ‚âÉ (hA ‚âÖ hB)
      thr = con _ res
      -- p : _ ‚Üí (hX : Object) ‚Üí Path (hA ‚âÖ hB) (hA ‚â° hB)
      -- p = ?
      -- p hA X i0 = hA ~ X
      -- p hA X i1 = Path Obj hA X

      -- From Thierry:
      --
      -- -Any- equality proof of
      --
      -- Id (Obj C) c0 c1
      --
      -- and
      --
      -- iso c0 c1
      --
      -- is enough to ensure univalence.
      -- This is because this implies that
      --
      -- Sigma (x : Obj C) is c0 x
      --
      -- is contractible, which implies univalence.

    module _ (hA : Object) where
      open Œ£ hA renaming (proj‚ÇÅ to A)

      center : Œ£[ hB ‚àà Object ] (hA ‚âÖ hB)
      center = hA , idIso hA
      open Œ£ center renaming ({-proj‚ÇÅ to hA ;-} proj‚ÇÇ to isoA) using ()

      module _ (y : Œ£[ hC ‚àà Object ] (hA ‚âÖ hC)) where
        open Œ£ y renaming (proj‚ÇÅ to hC ; proj‚ÇÇ to hA‚âÖhC)
        open Œ£ hC renaming (proj‚ÇÅ to C)

        open Œ£ hA‚âÖhC  renaming (proj‚ÇÅ to obv ; proj‚ÇÇ to iso)
        open Œ£ iso    renaming (proj‚ÇÅ to inv ; proj‚ÇÇ to areInv)

        -- Idea:
        -- Have : hA ‚âÖ hC
        -- Can I then construct `A Eqv.‚âÖ C`
        -- Cuz then it follows from univalence
        A‚â°C : A ‚â° C
        A‚â°C = ua s
          where
          s0 : A Eqv.‚âÖ C
          s0 = obv , inv , Eqv.toAreInverses areInv
          s : A ‚âÉ C
          s = fromIsomorphism s0

        pObj : hA ‚â° hC
        pObj = lemSig (Œª _ ‚Üí isSetIsProp) hA hC A‚â°C

        abstract
          isoEq
            : (Œª i ‚Üí Œ£ (A ‚Üí proj‚ÇÅ (pObj i)) (Isomorphism {A = hA} {pObj i}))
            [ idIso hA ‚â° hA‚âÖhC ]
          isoEq = {!!}
            where
            d : ‚àÄ iso ‚Üí (Œª _ ‚Üí Œ£ (A ‚Üí A) (Isomorphism {A = hA} {hA}))
              [ idIso hA ‚â° iso ]
            d iso = {!!}

        isContractible : (hA , idIso hA) ‚â° (hC , hA‚âÖhC)
        isContractible = Œ£‚â° pObj {!isoEq!}
        -- isContractible = lemSig prop‚âÖ center y pObj

      univalent[Contr] : isContr (Œ£[ hB ‚àà Object ] hA ‚âÖ hB)
      univalent[Contr] = center , isContractible

    univalent : Univalent
    univalent = from[Contr] univalent[Contr]

    SetsIsCategory : IsCategory SetsRaw
    IsCategory.isAssociative SetsIsCategory = refl
    IsCategory.isIdentity    SetsIsCategory {A} {B} = isIdentity    {A} {B}
    IsCategory.arrowsAreSets SetsIsCategory {A} {B} = arrowsAreSets {A} {B}
    IsCategory.univalent     SetsIsCategory = univalent

  ùì¢ùìÆùìΩ Sets : Category (lsuc ‚Ñì) ‚Ñì
  Category.raw ùì¢ùìÆùìΩ = SetsRaw
  Category.isCategory ùì¢ùìÆùìΩ = SetsIsCategory
  Sets = ùì¢ùìÆùìΩ

module _ {‚Ñì : Level} where
  private
    ùì¢ = ùì¢ùìÆùìΩ ‚Ñì
    open Category ùì¢
    open import Cubical.Sigma

    module _ (hA hB : Object) where
      open Œ£ hA renaming (proj‚ÇÅ to A ; proj‚ÇÇ to sA)
      open Œ£ hB renaming (proj‚ÇÅ to B ; proj‚ÇÇ to sB)

      private
        productObject : Object
        productObject = (A √ó B) , sigPresSet sA Œª _ ‚Üí sB

        module _ {X A B : Set ‚Ñì} (f : X ‚Üí A) (g : X ‚Üí B) where
          _&&&_ : (X ‚Üí A √ó B)
          _&&&_ x = f x , g x

        module _ (hX : Object) where
          open Œ£ hX renaming (proj‚ÇÅ to X)
          module _ (f : X ‚Üí A ) (g : X ‚Üí B) where
            ump : proj‚ÇÅ Function.‚àò‚Ä≤ (f &&& g) ‚â° f √ó proj‚ÇÇ Function.‚àò‚Ä≤ (f &&& g) ‚â° g
            proj‚ÇÅ ump = refl
            proj‚ÇÇ ump = refl

        rawProduct : RawProduct ùì¢ hA hB
        RawProduct.object rawProduct = productObject
        RawProduct.proj‚ÇÅ  rawProduct = Data.Product.proj‚ÇÅ
        RawProduct.proj‚ÇÇ  rawProduct = Data.Product.proj‚ÇÇ

        isProduct : IsProduct ùì¢ _ _ rawProduct
        IsProduct.ump isProduct {X = hX} f g
          = (f &&& g) , ump hX f g

      product : Product ùì¢ hA hB
      Product.raw       product = rawProduct
      Product.isProduct product = isProduct

  instance
    SetsHasProducts : HasProducts ùì¢
    SetsHasProducts = record { product = product }

module _ {‚Ñìa ‚Ñìb : Level} (‚ÑÇ : Category ‚Ñìa ‚Ñìb) where
  open Category ‚ÑÇ

  -- Covariant Presheaf
  Representable : Set (‚Ñìa ‚äî lsuc ‚Ñìb)
  Representable = Functor ‚ÑÇ (ùì¢ùìÆùìΩ ‚Ñìb)

  -- Contravariant Presheaf
  Presheaf : Set (‚Ñìa ‚äî lsuc ‚Ñìb)
  Presheaf = Functor (opposite ‚ÑÇ) (ùì¢ùìÆùìΩ ‚Ñìb)

  -- The "co-yoneda" embedding.
  representable : Category.Object ‚ÑÇ ‚Üí Representable
  representable A = record
    { raw = record
      { omap = Œª B ‚Üí ‚ÑÇ [ A , B ] , arrowsAreSets
      ; fmap = ‚ÑÇ [_‚àò_]
      }
    ; isFunctor = record
      { isIdentity     = funExt Œª _ ‚Üí leftIdentity
      ; isDistributive = funExt Œª x ‚Üí sym isAssociative
      }
    }

  -- Alternate name: `yoneda`
  presheaf : Category.Object (opposite ‚ÑÇ) ‚Üí Presheaf
  presheaf B = record
    { raw = record
      { omap = Œª A ‚Üí ‚ÑÇ [ A , B ] , arrowsAreSets
      ; fmap = Œª f g ‚Üí ‚ÑÇ [ g ‚àò f ]
    }
    ; isFunctor = record
      { isIdentity     = funExt Œª x ‚Üí rightIdentity
      ; isDistributive = funExt Œª x ‚Üí isAssociative
      }
    }
