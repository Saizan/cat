-- There is no category of categories in our interpretation
{-# OPTIONS --cubical --allow-unsolved-metas #-}

module Cat.Categories.Cat where

open import Agda.Primitive
open import Cubical
open import Function
open import Data.Product renaming (proj‚ÇÅ to fst ; proj‚ÇÇ to snd)

open import Cat.Category
open import Cat.Category.Functor
open import Cat.Category.Product
open import Cat.Category.Exponential

open import Cat.Equality
open Equality.Data.Product

open Functor
open IsFunctor
open Category using (Object ; ùüô)

-- The category of categories
module _ (‚Ñì ‚Ñì' : Level) where
  private
    module _ {ùî∏ ùîπ ‚ÑÇ ùîª : Category ‚Ñì ‚Ñì'} {F : Functor ùî∏ ùîπ} {G : Functor ùîπ ‚ÑÇ} {H : Functor ‚ÑÇ ùîª} where
      private
        eq* : func* (H ‚àòf (G ‚àòf F)) ‚â° func* ((H ‚àòf G) ‚àòf F)
        eq* = refl
        eq‚Üí : PathP
          (Œª i ‚Üí {A B : Object ùî∏} ‚Üí ùî∏ [ A , B ] ‚Üí ùîª [ eq* i A , eq* i B ])
          (func‚Üí (H ‚àòf (G ‚àòf F))) (func‚Üí ((H ‚àòf G) ‚àòf F))
        eq‚Üí = refl
        postulate
          eqI
            : (Œª i ‚Üí ‚àÄ {A : Object ùî∏} ‚Üí eq‚Üí i (ùüô ùî∏ {A}) ‚â° ùüô ùîª {eq* i A})
            [ (H ‚àòf (G ‚àòf F)) .isFunctor .ident
            ‚â° ((H ‚àòf G) ‚àòf F) .isFunctor .ident
            ]
          eqD
            : (Œª i ‚Üí ‚àÄ {A B C} {f : ùî∏ [ A , B ]} {g : ùî∏ [ B , C ]}
              ‚Üí eq‚Üí i (ùî∏ [ g ‚àò f ]) ‚â° ùîª [ eq‚Üí i g ‚àò eq‚Üí i f ])
            [ (H ‚àòf (G ‚àòf F)) .isFunctor .distrib
            ‚â° ((H ‚àòf G) ‚àòf F) .isFunctor .distrib
            ]

      assc : H ‚àòf (G ‚àòf F) ‚â° (H ‚àòf G) ‚àòf F
      assc = Functor‚â° eq* eq‚Üí

    module _ {‚ÑÇ ùîª : Category ‚Ñì ‚Ñì'} {F : Functor ‚ÑÇ ùîª} where
      module _ where
        private
          eq* : (func* F) ‚àò (func* (identity {C = ‚ÑÇ})) ‚â° func* F
          eq* = refl
          -- lemmm : func‚Üí {C = A} {D = B} (f ‚àòf identity) ‚â° func‚Üí f
          eq‚Üí : PathP
            (Œª i ‚Üí
            {x y : Object ‚ÑÇ} ‚Üí ‚ÑÇ [ x , y ] ‚Üí ùîª [ func* F x , func* F y ])
            (func‚Üí (F ‚àòf identity)) (func‚Üí F)
          eq‚Üí = refl
          postulate
            eqI-r
              : (Œª i ‚Üí {c : Object ‚ÑÇ} ‚Üí (Œª _ ‚Üí ùîª [ func* F c , func* F c ])
                [ func‚Üí F (ùüô ‚ÑÇ) ‚â° ùüô ùîª ])
              [(F ‚àòf identity) .isFunctor .ident ‚â° F .isFunctor .ident ]
            eqD-r : PathP
                        (Œª i ‚Üí
                        {A B C : Object ‚ÑÇ} {f : ‚ÑÇ [ A , B ]} {g : ‚ÑÇ [ B , C ]} ‚Üí
                        eq‚Üí i (‚ÑÇ [ g ‚àò f ]) ‚â° ùîª [ eq‚Üí i g ‚àò eq‚Üí i f ])
                        ((F ‚àòf identity) .isFunctor .distrib) (F .isFunctor .distrib)
        ident-r : F ‚àòf identity ‚â° F
        ident-r = Functor‚â° eq* eq‚Üí
      module _ where
        private
          postulate
            eq* : func* (identity ‚àòf F) ‚â° func* F
            eq‚Üí : PathP
              (Œª i ‚Üí {x y : Object ‚ÑÇ} ‚Üí ‚ÑÇ [ x , y ] ‚Üí ùîª [ eq* i x , eq* i y ])
              (func‚Üí (identity ‚àòf F)) (func‚Üí F)
            eqI : (Œª i ‚Üí ‚àÄ {A : Object ‚ÑÇ} ‚Üí eq‚Üí i (ùüô ‚ÑÇ {A}) ‚â° ùüô ùîª {eq* i A})
                  [ ((identity ‚àòf F) .isFunctor .ident) ‚â° (F .isFunctor .ident) ]
            eqD : PathP (Œª i ‚Üí {A B C : Object ‚ÑÇ} {f : ‚ÑÇ [ A , B ]} {g : ‚ÑÇ [ B , C ]}
                 ‚Üí eq‚Üí i (‚ÑÇ [ g ‚àò f ]) ‚â° ùîª [ eq‚Üí i g ‚àò eq‚Üí i f ])
                 ((identity ‚àòf F) .isFunctor .distrib) (F .isFunctor .distrib)
                 -- (Œª z ‚Üí eq* i z) (eq‚Üí i)
        ident-l : identity ‚àòf F ‚â° F
        ident-l = Functor‚â° eq* eq‚Üí

  RawCat : RawCategory (lsuc (‚Ñì ‚äî ‚Ñì')) (‚Ñì ‚äî ‚Ñì')
  RawCat =
    record
      { Object = Category ‚Ñì ‚Ñì'
      ; Arrow = Functor
      ; ùüô = identity
      ; _‚àò_ = _‚àòf_
      -- What gives here? Why can I not name the variables directly?
      -- ; isCategory = record
      --   { assoc = Œª {_ _ _ _ F G H} ‚Üí assc {F = F} {G = G} {H = H}
      --   ; ident = ident-r , ident-l
      --   }
      }
  private
    open RawCategory
    assoc : IsAssociative RawCat
    assoc {f = F} {G} {H} = assc {F = F} {G = G} {H = H}
    -- TODO: Rename `ident'` to `ident` after changing how names are exposed in Functor.
    ident' : IsIdentity RawCat identity
    ident' = ident-r , ident-l
    -- NB! `ArrowsAreSets RawCat` is *not* provable. The type of functors,
    -- however, form a groupoid! Therefore there is no (1-)category of
    -- categories. There does, however, exist a 2-category of 1-categories.

  -- Because of the note above there is not category of categories.
  Cat : (unprovable : IsCategory RawCat) ‚Üí Category (lsuc (‚Ñì ‚äî ‚Ñì')) (‚Ñì ‚äî ‚Ñì')
  Category.raw        (Cat _) = RawCat
  Category.isCategory (Cat unprovable) = unprovable
  -- Category.raw Cat _ = RawCat
  -- Category.isCategory Cat unprovable = unprovable

-- The following to some extend depends on the category of categories being a
-- category. In some places it may not actually be needed, however.
module _ {‚Ñì ‚Ñì' : Level} (unprovable : IsCategory (RawCat ‚Ñì ‚Ñì')) where
  module _ (‚ÑÇ ùîª : Category ‚Ñì ‚Ñì') where
    private
      Catt = Cat ‚Ñì ‚Ñì' unprovable
      :Object: = Object ‚ÑÇ √ó Object ùîª
      :Arrow:  : :Object: ‚Üí :Object: ‚Üí Set ‚Ñì'
      :Arrow: (c , d) (c' , d') = ‚ÑÇ [ c , c' ] √ó ùîª [ d , d' ]
      :ùüô: : {o : :Object:} ‚Üí :Arrow: o o
      :ùüô: = ùüô ‚ÑÇ , ùüô ùîª
      _:‚äï:_ :
        {a b c : :Object:} ‚Üí
        :Arrow: b c ‚Üí
        :Arrow: a b ‚Üí
        :Arrow: a c
      _:‚äï:_ = Œª { (bc‚ààC , bc‚ààD) (ab‚ààC , ab‚ààD) ‚Üí ‚ÑÇ [ bc‚ààC ‚àò ab‚ààC ] , ùîª [ bc‚ààD ‚àò ab‚ààD ]}

      :rawProduct: : RawCategory ‚Ñì ‚Ñì'
      RawCategory.Object :rawProduct: = :Object:
      RawCategory.Arrow :rawProduct: = :Arrow:
      RawCategory.ùüô :rawProduct: = :ùüô:
      RawCategory._‚àò_ :rawProduct: = _:‚äï:_
      open RawCategory :rawProduct:

      module C = Category ‚ÑÇ
      module D = Category ùîª
      postulate
        issSet : {A B : RawCategory.Object :rawProduct:} ‚Üí isSet (Arrow A B)
      ident' : IsIdentity :ùüô:
      ident'
        = Œ£‚â° (fst C.ident) (fst D.ident)
        , Œ£‚â° (snd C.ident) (snd D.ident)
      postulate univalent : Univalence.Univalent :rawProduct: ident'
      instance
        :isCategory: : IsCategory :rawProduct:
        IsCategory.assoc :isCategory: = Œ£‚â° C.assoc D.assoc
        IsCategory.ident :isCategory: = ident'
        IsCategory.arrowIsSet :isCategory: = issSet
        IsCategory.univalent :isCategory: = univalent

      :product: : Category ‚Ñì ‚Ñì'
      Category.raw :product: = :rawProduct:

      proj‚ÇÅ : Catt [ :product: , ‚ÑÇ ]
      proj‚ÇÅ = record
        { raw = record { func* = fst ; func‚Üí = fst }
        ; isFunctor = record { ident = refl ; distrib = refl }
        }

      proj‚ÇÇ : Catt [ :product: , ùîª ]
      proj‚ÇÇ = record
        { raw = record { func* = snd ; func‚Üí = snd }
        ; isFunctor = record { ident = refl ; distrib = refl }
        }

      module _ {X : Object Catt} (x‚ÇÅ : Catt [ X , ‚ÑÇ ]) (x‚ÇÇ : Catt [ X , ùîª ]) where
        open Functor

        postulate x : Functor X :product:
        -- x = record
        --   { func* = Œª x ‚Üí x‚ÇÅ .func* x , x‚ÇÇ .func* x
        --   ; func‚Üí = Œª x ‚Üí func‚Üí x‚ÇÅ x , func‚Üí x‚ÇÇ x
        --   ; isFunctor = record
        --     { ident   = Œ£‚â° x‚ÇÅ.ident x‚ÇÇ.ident
        --     ; distrib = Œ£‚â° x‚ÇÅ.distrib x‚ÇÇ.distrib
        --     }
        --   }
        --   where
        --     open module x‚ÇÅ = IsFunctor (x‚ÇÅ .isFunctor)
        --     open module x‚ÇÇ = IsFunctor (x‚ÇÇ .isFunctor)

        -- Turned into postulate after:
        -- > commit e8215b2c051062c6301abc9b3f6ec67106259758 (HEAD -> dev, github/dev)
        -- > Author: Frederik Hangh√∏j Iversen <fhi.1990@gmail.com>
        -- > Date:   Mon Feb 5 14:59:53 2018 +0100
        postulate isUniqL : Catt [ proj‚ÇÅ ‚àò x ] ‚â° x‚ÇÅ
        -- isUniqL = Functor‚â° eq* eq‚Üí {!!}
        --   where
        --     eq* : (Catt [ proj‚ÇÅ ‚àò x ]) .func* ‚â° x‚ÇÅ .func*
        --     eq* = {!refl!}
        --     eq‚Üí : (Œª i ‚Üí {A : Object X} {B : Object X} ‚Üí X [ A , B ] ‚Üí ‚ÑÇ [ eq* i A , eq* i B ])
        --             [ (Catt [ proj‚ÇÅ ‚àò x ]) .func‚Üí ‚â° x‚ÇÅ .func‚Üí ]
        --     eq‚Üí = refl
            -- postulate eqIsF : (Catt [ proj‚ÇÅ ‚àò x ]) .isFunctor ‚â° x‚ÇÅ .isFunctor
            -- eqIsF = IsFunctor‚â° {!refl!} {!!}

        postulate isUniqR : Catt [ proj‚ÇÇ ‚àò x ] ‚â° x‚ÇÇ
        -- isUniqR = Functor‚â° refl refl {!!} {!!}

        isUniq : Catt [ proj‚ÇÅ ‚àò x ] ‚â° x‚ÇÅ √ó Catt [ proj‚ÇÇ ‚àò x ] ‚â° x‚ÇÇ
        isUniq = isUniqL , isUniqR

        uniq : ‚àÉ![ x ] (Catt [ proj‚ÇÅ ‚àò x ] ‚â° x‚ÇÅ √ó Catt [ proj‚ÇÇ ‚àò x ] ‚â° x‚ÇÇ)
        uniq = x , isUniq

    instance
      isProduct : IsProduct Catt proj‚ÇÅ proj‚ÇÇ
      isProduct = uniq

    product : Product {‚ÑÇ = Catt} ‚ÑÇ ùîª
    product = record
      { obj = :product:
      ; proj‚ÇÅ = proj‚ÇÅ
      ; proj‚ÇÇ = proj‚ÇÇ
      }

module _ {‚Ñì ‚Ñì' : Level} (unprovable : IsCategory (RawCat ‚Ñì ‚Ñì')) where
  Catt = Cat ‚Ñì ‚Ñì' unprovable
  instance
    hasProducts : HasProducts Catt
    hasProducts = record { product = product unprovable }

-- Basically proves that `Cat ‚Ñì ‚Ñì` is cartesian closed.
module _ (‚Ñì : Level) (unprovable : IsCategory (RawCat ‚Ñì ‚Ñì)) where
  private
    open Data.Product
    open import Cat.Categories.Fun

    Cat‚Ñì : Category (lsuc (‚Ñì ‚äî ‚Ñì)) (‚Ñì ‚äî ‚Ñì)
    Cat‚Ñì = Cat ‚Ñì ‚Ñì unprovable
    module _ (‚ÑÇ ùîª : Category ‚Ñì ‚Ñì) where
      private
        :obj: : Object Cat‚Ñì
        :obj: = Fun {‚ÑÇ = ‚ÑÇ} {ùîª = ùîª}

        :func*: : Functor ‚ÑÇ ùîª √ó Object ‚ÑÇ ‚Üí Object ùîª
        :func*: (F , A) = func* F A

      module _ {dom cod : Functor ‚ÑÇ ùîª √ó Object ‚ÑÇ} where
        private
          F : Functor ‚ÑÇ ùîª
          F = proj‚ÇÅ dom
          A : Object ‚ÑÇ
          A = proj‚ÇÇ dom

          G : Functor ‚ÑÇ ùîª
          G = proj‚ÇÅ cod
          B : Object ‚ÑÇ
          B = proj‚ÇÇ cod

        :func‚Üí: : (pobj : NaturalTransformation F G √ó ‚ÑÇ [ A , B ])
          ‚Üí ùîª [ func* F A , func* G B ]
        :func‚Üí: ((Œ∏ , Œ∏Nat) , f) = result
          where
            Œ∏A : ùîª [ func* F A , func* G A ]
            Œ∏A = Œ∏ A
            Œ∏B : ùîª [ func* F B , func* G B ]
            Œ∏B = Œ∏ B
            F‚Üíf : ùîª [ func* F A , func* F B ]
            F‚Üíf = func‚Üí F f
            G‚Üíf : ùîª [ func* G A , func* G B ]
            G‚Üíf = func‚Üí G f
            l : ùîª [ func* F A , func* G B ]
            l = ùîª [ Œ∏B ‚àò F‚Üíf ]
            r : ùîª [ func* F A , func* G B ]
            r = ùîª [ G‚Üíf ‚àò Œ∏A ]
            -- There are two choices at this point,
            -- but I suppose the whole point is that
            -- by `Œ∏Nat f` we have `l ‚â° r`
            --     lem : ùîª [ Œ∏ B ‚àò F .func‚Üí f ] ‚â° ùîª [ G .func‚Üí f ‚àò Œ∏ A ]
            --     lem = Œ∏Nat f
            result : ùîª [ func* F A , func* G B ]
            result = l

      _√óp_ = product unprovable

      module _ {c : Functor ‚ÑÇ ùîª √ó Object ‚ÑÇ} where
        private
          F : Functor ‚ÑÇ ùîª
          F = proj‚ÇÅ c
          C : Object ‚ÑÇ
          C = proj‚ÇÇ c

        -- NaturalTransformation F G √ó ‚ÑÇ .Arrow A B
        -- :ident: : :func‚Üí: {c} {c} (identityNat F , ‚ÑÇ .ùüô) ‚â° ùîª .ùüô
        -- :ident: = trans (proj‚ÇÇ ùîª.ident) (F .ident)
        --   where
        --     open module ùîª = IsCategory (ùîª .isCategory)
        -- Unfortunately the equational version has some ambigous arguments.
        :ident: : :func‚Üí: {c} {c} (identityNat F , ùüô ‚ÑÇ {A = proj‚ÇÇ c}) ‚â° ùüô ùîª
        :ident: = begin
          :func‚Üí: {c} {c} (ùüô (Product.obj (:obj: √óp ‚ÑÇ)) {c}) ‚â°‚ü®‚ü©
          :func‚Üí: {c} {c} (identityNat F , ùüô ‚ÑÇ)             ‚â°‚ü®‚ü©
          ùîª [ identityTrans F C ‚àò func‚Üí F (ùüô ‚ÑÇ)]           ‚â°‚ü®‚ü©
          ùîª [ ùüô ùîª ‚àò func‚Üí F (ùüô ‚ÑÇ)]                        ‚â°‚ü® proj‚ÇÇ ùîª.ident ‚ü©
          func‚Üí F (ùüô ‚ÑÇ)                                    ‚â°‚ü® F.ident ‚ü©
          ùüô ùîª                                               ‚àé
          where
            open module ùîª = Category ùîª
            open module F = IsFunctor (F .isFunctor)

      module _ {F√óA G√óB H√óC : Functor ‚ÑÇ ùîª √ó Object ‚ÑÇ} where
        F = F√óA .proj‚ÇÅ
        A = F√óA .proj‚ÇÇ
        G = G√óB .proj‚ÇÅ
        B = G√óB .proj‚ÇÇ
        H = H√óC .proj‚ÇÅ
        C = H√óC .proj‚ÇÇ
        -- Not entirely clear what this is at this point:
        _P‚äï_ = Category._‚àò_ (Product.obj (:obj: √óp ‚ÑÇ)) {F√óA} {G√óB} {H√óC}
        module _
          -- NaturalTransformation F G √ó ‚ÑÇ .Arrow A B
          {Œ∏√óf : NaturalTransformation F G √ó ‚ÑÇ [ A , B ]}
          {Œ∑√óg : NaturalTransformation G H √ó ‚ÑÇ [ B , C ]} where
          private
            Œ∏ : Transformation F G
            Œ∏ = proj‚ÇÅ (proj‚ÇÅ Œ∏√óf)
            Œ∏Nat : Natural F G Œ∏
            Œ∏Nat = proj‚ÇÇ (proj‚ÇÅ Œ∏√óf)
            f : ‚ÑÇ [ A , B ]
            f = proj‚ÇÇ Œ∏√óf
            Œ∑ : Transformation G H
            Œ∑ = proj‚ÇÅ (proj‚ÇÅ Œ∑√óg)
            Œ∑Nat : Natural G H Œ∑
            Œ∑Nat = proj‚ÇÇ (proj‚ÇÅ Œ∑√óg)
            g : ‚ÑÇ [ B , C ]
            g = proj‚ÇÇ Œ∑√óg

            Œ∑Œ∏NT : NaturalTransformation F H
            Œ∑Œ∏NT = Category._‚àò_ Fun {F} {G} {H} (Œ∑ , Œ∑Nat) (Œ∏ , Œ∏Nat)

            Œ∑Œ∏ = proj‚ÇÅ Œ∑Œ∏NT
            Œ∑Œ∏Nat = proj‚ÇÇ Œ∑Œ∏NT

          :distrib: :
              ùîª [ ùîª [ Œ∑ C ‚àò Œ∏ C ] ‚àò func‚Üí F ( ‚ÑÇ [ g ‚àò f ] ) ]
            ‚â° ùîª [ ùîª [ Œ∑ C ‚àò func‚Üí G g ] ‚àò ùîª [ Œ∏ B ‚àò func‚Üí F f ] ]
          :distrib: = begin
            ùîª [ (Œ∑Œ∏ C) ‚àò func‚Üí F (‚ÑÇ [ g ‚àò f ]) ]
              ‚â°‚ü® Œ∑Œ∏Nat (‚ÑÇ [ g ‚àò f ]) ‚ü©
            ùîª [ func‚Üí H (‚ÑÇ [ g ‚àò f ]) ‚àò (Œ∑Œ∏ A) ]
              ‚â°‚ü® cong (Œª œÜ ‚Üí ùîª [ œÜ ‚àò Œ∑Œ∏ A ]) (H.distrib) ‚ü©
            ùîª [ ùîª [ func‚Üí H g ‚àò func‚Üí H f ] ‚àò (Œ∑Œ∏ A) ]
              ‚â°‚ü® sym assoc ‚ü©
            ùîª [ func‚Üí H g ‚àò ùîª [ func‚Üí H f ‚àò Œ∑Œ∏ A ] ]
              ‚â°‚ü® cong (Œª œÜ ‚Üí ùîª [ func‚Üí H g ‚àò œÜ ]) assoc ‚ü©
            ùîª [ func‚Üí H g ‚àò ùîª [ ùîª [ func‚Üí H f ‚àò Œ∑ A ] ‚àò Œ∏ A ] ]
              ‚â°‚ü® cong (Œª œÜ ‚Üí ùîª [ func‚Üí H g ‚àò œÜ ]) (cong (Œª œÜ ‚Üí ùîª [ œÜ ‚àò Œ∏ A ]) (sym (Œ∑Nat f))) ‚ü©
            ùîª [ func‚Üí H g ‚àò ùîª [ ùîª [ Œ∑ B ‚àò func‚Üí G f ] ‚àò Œ∏ A ] ]
              ‚â°‚ü® cong (Œª œÜ ‚Üí ùîª [ func‚Üí H g ‚àò œÜ ]) (sym assoc) ‚ü©
            ùîª [ func‚Üí H g ‚àò ùîª [ Œ∑ B ‚àò ùîª [ func‚Üí G f ‚àò Œ∏ A ] ] ]
              ‚â°‚ü® assoc ‚ü©
            ùîª [ ùîª [ func‚Üí H g ‚àò Œ∑ B ] ‚àò ùîª [ func‚Üí G f ‚àò Œ∏ A ] ]
              ‚â°‚ü® cong (Œª œÜ ‚Üí ùîª [ œÜ ‚àò ùîª [ func‚Üí G f ‚àò Œ∏ A ] ]) (sym (Œ∑Nat g)) ‚ü©
            ùîª [ ùîª [ Œ∑ C ‚àò func‚Üí G g ] ‚àò ùîª [ func‚Üí G f ‚àò Œ∏ A ] ]
              ‚â°‚ü® cong (Œª œÜ ‚Üí ùîª [ ùîª [ Œ∑ C ‚àò func‚Üí G g ] ‚àò œÜ ]) (sym (Œ∏Nat f)) ‚ü©
            ùîª [ ùîª [ Œ∑ C ‚àò func‚Üí G g ] ‚àò ùîª [ Œ∏ B ‚àò func‚Üí F f ] ] ‚àé
            where
              open Category ùîª
              module H = IsFunctor (H .isFunctor)

      :eval: : Functor ((:obj: √óp ‚ÑÇ) .Product.obj) ùîª
      :eval: = record
        { raw = record
          { func* = :func*:
          ; func‚Üí = Œª {dom} {cod} ‚Üí :func‚Üí: {dom} {cod}
          }
        ; isFunctor = record
          { ident = Œª {o} ‚Üí :ident: {o}
          ; distrib = Œª {f u n k y} ‚Üí :distrib: {f} {u} {n} {k} {y}
          }
        }

      module _ (ùî∏ : Category ‚Ñì ‚Ñì) (F : Functor ((ùî∏ √óp ‚ÑÇ) .Product.obj) ùîª) where
        open HasProducts (hasProducts {‚Ñì} {‚Ñì} unprovable) renaming (_|√ó|_ to parallelProduct)

        postulate
          transpose : Functor ùî∏ :obj:
          eq : Cat‚Ñì [ :eval: ‚àò (parallelProduct transpose (ùüô Cat‚Ñì {A = ‚ÑÇ})) ] ‚â° F
          -- eq : Cat‚Ñì [ :eval: ‚àò (HasProducts._|√ó|_ hasProducts transpose (ùüô Cat‚Ñì {o = ‚ÑÇ})) ] ‚â° F
          -- eq' : (Cat‚Ñì [ :eval: ‚àò
          --   (record { product = product } HasProducts.|√ó| transpose)
          --   (ùüô Cat‚Ñì)
          --   ])
          --   ‚â° F

        -- For some reason after `e8215b2c051062c6301abc9b3f6ec67106259758`
        -- `catTranspose` makes Agda hang. catTranspose : ‚àÉ![ F~ ] (Cat‚Ñì [
        -- :eval: ‚àò (parallelProduct F~ (ùüô Cat‚Ñì {o = ‚ÑÇ}))] ‚â° F) catTranspose =
        -- transpose , eq

      postulate :isExponential: : IsExponential Cat‚Ñì ‚ÑÇ ùîª :obj: :eval:
      -- :isExponential: : IsExponential Cat‚Ñì ‚ÑÇ ùîª :obj: :eval:
      -- :isExponential: = {!catTranspose!}
      --   where
      --     open HasProducts (hasProducts {‚Ñì} {‚Ñì} unprovable) using (_|√ó|_)
      -- :isExponential: = Œª ùî∏ F ‚Üí transpose ùî∏ F , eq' ùî∏ F

      -- :exponent: : Exponential (Cat ‚Ñì ‚Ñì) A B
      :exponent: : Exponential Cat‚Ñì ‚ÑÇ ùîª
      :exponent: = record
        { obj = :obj:
        ; eval = :eval:
        ; isExponential = :isExponential:
        }

  hasExponentials : HasExponentials Cat‚Ñì
  hasExponentials = record { exponent = :exponent: }
